---
title: "Itkonen Structures 50 Years On"
author:
  - Madelaine O'Reilly-Brown, Stanford University
  - Brandon Papineau, Stanford University
  - Arto Anttila, Stanford University
  - Paul Kiparsky, Stanford University
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: rmdformats::readthedown
---

<!-- This bit above is kind of similar to a LaTeX preamble, except that libraries (packages) get loaded in the actual code, rather than up here: -->


<!-- SETTING UP THE DATA: COMMENTED INSTRUCTIONS-->

```{r include=FALSE}

#This chode chunk loads the 4 libraries needed for the analysis and visualization

library(tidyverse) #Tidy data, ggplot2, etc.
library(mlogit) #logit function, for multinomial analyses
library(lme4) #for mixed logistic binomial regressions
library(formattable,DT) # Prettier tables
library(rmdformats) # For the custom html output


# Here's some custom visual styling stuff

bran_palette = c("#7ae7e5", "#fe5f55", "#B2A6DE", "#14342b", "#69385c") 
voice_palette = c("#3d405b","#e07a5f") #Defines a custom color palette we can use in ggplot graphs; stored as a list of hex codes
type_palette = c("#BBF2D0","#758ECD")

# FAA6FF Additional HEX 

# "#81b29a","f2cc8f"

theme_set(theme_bw()) #Sets the defaut theme of all ggplot objects to black & white

customGreen = "#71CA97" #Another custom green for the formattable tables

```

```{r echo=FALSE}
# I'm also importing a custom function from [https://mikeyharper.uk/about/] which allows us to collapse table rows when they have the same values 

# Collapse the values within a grouped dataframe
collapse_rows_df <- function(df, variable){

  group_var <- enquo(variable)

  df %>%
    group_by(!! group_var) %>%
    mutate(groupRow = 1:n()) %>%
    ungroup() %>%
    mutate(!!quo_name(group_var) := ifelse(groupRow == 1, as.character(!! group_var), "")) %>%
    select(-c(groupRow))
}
```

<!-- Now we can read-in the experiment-generated csv. We also want to filter out the training trials (where choice == "True"), and rename the subject_information.demogrpahic columns to be more usable. While we do that, we will also make sure they get read into the data frame as factors, rather than characters. -->

```{r echo=FALSE}
itkonen <- read.csv("itkonen-rep.csv") %>% 
  filter(choice != "True") %>% 
  mutate(comments = subject_information.comments,
         age = as.numeric(subject_information.age),
         gender = as.factor(subject_information.gender),
         region = as.factor(subject_information.region),
         education = as.numeric(subject_information.education)) %>% 
  select(-c("subject_information.gender","subject_information.comments","subject_information.age","subject_information.region","subject_information.education"))
```

<!-- We also want to read in the by-item proportions from Itkonen's original study: -->

```{r echo=FALSE}
itkonenOriginal <- read.csv("itkonen-original.csv")
```

<!-- ### Set Response Cases -->

<!-- This code creates the 4 bins of responses we have. The first three are lists of the different cases' realizations in the critical items. The last is the same, but will let us code for attention checks. -->

```{r echo=FALSE}
nomForms = c("kappalainen","harvinainen erikoistapaus","valtio valtiossa","persikka","tulipalo","jokin maininta","mikään maininta","persoonallinen suhde"," kappalainen")
```

```{r echo=FALSE}
genForms = c("kappalaisen","harvinaisen erikoistapauksen","valtion valtiossa","persikan","tulipalon","jonkin maininnan","minkään maininnan","persoonallisen suhteen")
```

```{r echo=FALSE}
partForms = c("kappalaista","harvinaista erikoistapausta","valtiota valtiossa","persikkaa","tulipaloa","mitään mainintaa","persoonallista suhdetta")
```

```{r echo=FALSE}
attForms = c("on","olet","olen")
```

<!-- ### Mutate to add Response Case for each trial -->

<!-- With that done, we can actually code all the responses in the whole new data frame for their case response, coded as responseCase -->

```{r echo=FALSE}
itkonen <- itkonen %>% 
  mutate("responseCase" = case_when(
    response %in% nomForms ~ "nom", #if the reponse case is available in the above-defined nominative list, create a new column with the value "nom" for that trial
    response %in% genForms ~ "gen", # ... and the same for genitive and partitive, as well as attention
    response %in% partForms ~ "part",
    response %in% attForms ~ "attn",
    TRUE ~ "uncoded"
  ))
```

<!-- ## Exclusions -->

<!-- *Generate Exclusion List* -->

<!-- This code allows us to create an exclusion list, or a list of all participants who didn't score 100% on our three attention checks.  -->

```{r echo=FALSE}
exclusionList <- itkonen %>% 
  filter(responseCase == "attn") %>% # Take only the attention trials
  group_by(workerid) %>% # Group the data frame by each participant
  summarise(accuracy = mean(as.numeric(attention))) %>% # For each participant, calculate a score between 0-1, the mean of their attention checks; 1 = passed attention check, 0 = failed attention check
  mutate(exclude = ifelse(accuracy < 1,'Yes','No')) %>% #If that mean is anything lower than 1 (perfect attention), we want to give them the characteristic "EXCLUDE=TRUE"
  filter(exclude == "Yes") #Now filter out all the people who passed, so we get a list of the people who failed only
```

<!-- *Run Exclusion Filter* -->

```{r echo=FALSE}
itkonen <- itkonen[!(itkonen$workerid %in% exclusionList$workerid),] #Now remove from the full dataframe all the participants who are listed on the list we just created
```

# Introduction

The issue of object case assignment in Finnish is one of longstanding interest to linguists due to the complex interaction of semantic and syntactic variables involved. While significant steps have been made towards characterizing the object case assignment paradigm, there are two constructions, commonly referred to as “Itkonen structures” and “Ikola structures”, which resist neat categorization within the accounts that have been proposed so far, due to the fact that the case appearing on their embedded object appears to be in free variation between nominative and genitive. Itkonen structures, which will be the focus of this study, were first identified in Itkonen (1976), an experimental study of case variation in complex clauses. A prediction made in that study was that genitive case was gradually being replaced by nominative case, and that the case variation observed in Itkonen structures resulted from analogy from changes occurring in case assignment preferences in certain matrix clause configurations. This predicts not only that, nominative case should appear on embedded objects of Itkonen at a higher rate as time elapses, but also that this change should diffuse across Itkonen structures in a variety of contexts in a predictable manner, with those constructions bearing the most similarity to the analogous simplex clauses having progressed the furthest. 
  With regard to the mechanisms which derive the variation in case assignment, one strand of thought which appears frequently in minimalist accounts holds that this phenomenon is the result of a structural ambiguity (Vainikka & Brattico 2014, Ylinärä & Frascarelli, 2021). While the specifics of the claims vary, typically these accounts argue that there are two available structures, one in which the embedded clause is capable of assigning the object case itself, and one which involves a reduced clausal structure resulting in object case assignment by some matrix element. Given that, one might expect a difference with respect to certain biclausality diagnostics in speakers who prefer nominative or genitive case.
	In order to test the predictions made in Itkonen (1976), as well as the claims of minimalist accounts which argue for different amounts of embedded structure, we created an experimental study consisting of two parts. The first section is an exact replication of the study in Itkonen (1976), in which participants were asked to fill in the blank with an embedded object with the case of their choice, while the second portion asks participants to perform the same sort of task, except with a subsection of the original Itkonen (1976) stimuli in which there is negation in the matrix clause (case assignment under negation being a common test for biclausality in Finnish). 
	

## Background

Objects in Finnish can appear in one of four cases: partitive, accusative, genitive, and nominative. Only the nominative and the genitive appear in free variation on embedded objects of Itkonen structures, hence they will be the focus of this study. Itkonen structures are nonfinite propositional complements headed by participle forms of verbs including 'say’ and 'think’ (Vainikka & Brattico, 2014). At the time of the Itkonen (1976) study, not all embedded objects of Itkonen structures were in free variation. Rather, the distribution of nominative and accusative case on embedded objects could be summarized as:

- Matrix verb active, embedded clause transitive: GEN
- Matrix verb passive, embedded clause transitive: NOM ~ GEN
- Matrix verb active, embedded clause existential: GEN preferred
- Matrix verb passive, embedded clause existential: NOM preferred
- Matrix verb active, embedded clause predicative: NOM preferred
- Matrix verb passive, embedded clause predicative: NOM strongly preferred

Itkonen (1976) argued that genitive case was the historically dominant form, while nominative case was in the process of replacing genitive due to analogy to simplex clauses. His study found that nominative was more common under passives than under actives, and more common in predicatives than existential. In their Optimality Theoretic account of object case variation, Vainikka & Brattico (2014) argue that the genitive-to-nominative shift started from predicative and passive matrix clauses, and is proceeding through existential and active matrix clauses. That taken together with Itkonen (1976) make the clear prediction that, in our replication study, we will find that, in comparison to the 1976 findings, (1) the nominative will consistently appear at higher frequencies on the embedded object of Itkonen structures, and (2), if there is still variation in case assignment, we should observe the rate of nominative case increase from matrix active, embedded existential contexts to matrix passive, embedded predicative contexts. 

The second portion of our experiment concerns case assignment under negation. It is a general fact about Finnish that object DPs under the scope of negation receive partitive case (Vainikka & Brattico, 2014). Minimalist accounts of the Finnish free-variation case assignment phenomenon have generally attempted to derive it by arguing that it derives from distinct structures with differing levels of independence from the matrix clause, meaning that the object of the less independent clause receives case from some matrix element, while the object of the more independent clause receives case clause-internally. For example, Vainikka & Brattico (2014) argue that certain embedded clauses can optionally include an AgrP which is capable of assigning genitive case, while Ylinärä & Frascarelli (2020) argue that variation derives from ambiguity between verbal and nominalized structures, with the embedded argument of the nominalization actually being a subject which receives genitive case. Interestingly, those two accounts make opposite claims as to which case type correlates with which (more or less independent) embedded clause type. If it is indeed the case that the choice of case on the embedded object correlates with different structural configurations, in which the embedded object can be assigned case by a matrix or embedded element, and additionally that speakers are consistent as to which of those two structures they employ (this is shown to be the case in Itkonen (1976), in which speakers were consistent in preferring either genitive or nominative case), then we may expect differences in object case under negation. For example, if a speaker opts for the structure in which the embedded clause is able to assign case to its embedded object, we might expect the embedded object not to receive partitive case when the matrix clause is negated. On the other hand, if the embedded object receives case from the matrix clause, we might expect it occur with partitive case. Furthermore, we anticipate that a speaker’s preference in non-negated contexts will correlate with their preference in negated contexts. 


## Itkonen's Original Results

Before continuing, it's worth noting Itkonen's original results, which he published in 1976.

```{r echo=FALSE}
itkonenOriginal %>%
  mutate(itemNomRateOriginal = 100*itemNomRateOriginal) %>% 
  rename("Item" = item,
         "Voice" = voice,
         "Type" = type,
         "Rate of Nominative (x/100)" = itemNomRateOriginal) %>% 
  select(-c("itemGenRateOriginal")) %>% 
  group_by(Item) %>%
  slice(1:4) %>% 
  select(Item, everything()) %>%
  collapse_rows_df(Item) %>%
  formattable(align=c("l"))
```

# Methods

## Participants
We used Itkonen's orignal sample size (n=126) as a benchmark for how many participants to recruit. Ultimately, 78 participants were recruited through the online recruitment platform [Prolific](https://Prolfic.co), all of whom self-identified as fluent and native speakers of Finnish. Participants were paid $2 for their participation in the study. 

## Stimuli 
The first 22 trials of the study contained stimuli identical to that of Itkonen (1976). There were 7 stimulus frames, of which 4 appeared in all 4 possible voice & structure combinations: 

- Active-Existential
- Active-Predicative
- Passive-Existential
- Passive-Predicative

The remaining 3 stimulus frames occurred only in the existential forms.

In the second half of the study, we added 15 negated sentences, which are predicted to only allow the partitive. The inclusion of these items was meant to investigate whether some speakers permit or produce the nominative or genitive, possibly by way of extension from the positive phrases. 

We additionally included two re-formulated versions of the 'jokin' stimulus item, due to Itkonen's original wording being judged as non-standard by the third author.

Finally, we included three attention check items in the second half of the study, all of which asked participants to inflect the copular verb for different persons. 

All modifications to the study (negated sentences, 'jokin' restructures, and attention checks) were included in the second half so as to be as faithful to Itkonen's original study as possible.


## Procedure
After providing informed consent, participants were instructed that they would be reading 40 sentences which needed to be completed, and that they should select one of the options provided to best complete the sentence. They then completed an example trial with a prescriptively correct answer, on the basis of verb inflection.

After this, participants proceeded through the 40 trials, selecting one of two or three presented options to complete the sentence. The first 22 replicated Itkonen's original study; items in this chunk were randomized between participants, and the order of options provided were also randomized. The last 18 items, which deviated from and added on to Itkonen's study, were similarly randomized. 

After completing the main study, participants were presented with a demographic questionnaire, which asked about age, education, gender, and county of Finland from which the participant came. All questions were optional.

A link to the experiment can be found [here](https://branpap.github.io/itkonen-replication/experiment/experiment.html). This version does **not** record responses, and is for demonstration purposes only.

# Results

```{r echo=FALSE}
ReplicationOnly <- itkonen %>% 
  filter(polarity == "positive") %>% 
  filter(item != "jokin2")
```

```{r include=FALSE}
replicationItems <- ReplicationOnly %>% 
  group_by(item,voice,type,responseCase) %>% 
  count() %>% 
  pivot_wider(names_from = responseCase,values_from = n) %>% 
  replace_na(list(gen=0)) %>% 
  summarize(itemNomRate = nom/(nom+gen),
            itemGenRate = 1-itemNomRate)
```

```{r include=FALSE}
compItems <- left_join(itkonenOriginal,replicationItems) 
```

```{r echo=FALSE}
compItems <- compItems %>% 
  mutate(itemNomRate = trunc(itemNomRate*10^2),
         itemGenRate = trunc(itemGenRate*10^2),
         itemNomRateOriginal = trunc(itemNomRateOriginal*10^2),
         itemGenRateOriginal = trunc(itemGenRateOriginal*10^2),
         nomChange = itemNomRate - itemNomRateOriginal) %>% 
  select(-c("itemGenRate","itemGenRateOriginal")) 
```

## Replication Study

In our faithful replication of Itkonen's original study, we find similar patterns to those in the original study, with regard to voice, structure, and item effects. We take each of these in turn here, before turning to the issue of changes between Itkonen's results and our own.

### Voice

```{r echo=FALSE}
ReplicationOnly %>% 
  group_by(voice,responseCase) %>% 
  count() %>% 
  pivot_wider(values_from = n, names_from = responseCase) %>% 
  summarize(nomRate = nom/(nom + gen)) %>% 
  ggplot(aes(x=voice,y=nomRate, fill=voice)) + 
  geom_bar(stat="identity") + 
  labs(x="Voice",y="Proportion of Responses",title="Replication Results: Voice") + 
  ylim(0,1) + 
  geom_text(aes(x=voice,y=nomRate, vjust =-.5, label=trunc(nomRate*10^2)/(10^2))) + 
  scale_fill_manual(values=voice_palette) + 
  theme_classic() +
  theme(legend.position = "none") 
```

### Structure

We found that...

```{r echo=FALSE}
ReplicationOnly %>% 
  group_by(type,responseCase) %>% 
  count() %>% 
  pivot_wider(values_from = n, names_from = responseCase) %>% 
  summarize(nomRate = nom/(nom + gen)) %>% 
  ggplot(aes(x=type,y=nomRate, fill=type)) + 
  geom_bar(stat="identity") + 
  labs(x="Voice",y="Proportion of Responses",title="Replication Results: Voice") + 
  ylim(0,1) + 
  geom_text(aes(x=type,y=nomRate, vjust =-.5, label=trunc(nomRate*10^2)/10^2)) + 
  scale_fill_manual(values = type_palette) + 
  theme_classic() + 
  theme(legend.position = "none") 
```

### Crossed Voice x Structure

```{r echo=FALSE, message=FALSE}
ReplicationOnly %>% 
  group_by(type,voice,responseCase) %>% 
  count() %>% 
  pivot_wider(values_from = n, names_from = responseCase) %>% 
  summarize(nomRate = nom/(nom+gen)) %>% 
  ggplot(aes(x=reorder(type, nomRate),y=nomRate, fill=type)) + 
  geom_bar(stat="identity") + 
  geom_text(aes(x=type,y=nomRate, vjust =-.5, label=trunc(nomRate*10^2))) +
  labs(x="Item", y="Proportion of Nominative Responses", title="Nominative Rates of Replication Items: Voice x Structure") + 
  scale_fill_manual(values=type_palette) + 
  facet_wrap(~voice) + 
  theme_classic() +
  ylim(0,1) + 
  theme(legend.position = "none") 
```

### Items

```{r echo=FALSE}
ReplicationOnly %>% 
  filter(type=="existential") %>% 
  group_by(item,responseCase) %>% 
  count() %>% 
  pivot_wider(values_from = n, names_from = responseCase) %>% 
  summarize(nomRate = nom/(nom+gen)) %>% 
  ggplot(aes(x=reorder(item, -nomRate),y=nomRate, fill=item)) + 
  geom_bar(stat="identity") + 
  geom_text(aes(x=item,y=nomRate, vjust =-.5, label=trunc(nomRate*10^2))) +
  labs(x="Item", y="Proportion of Nominative Responses", title="Nominative Rates of Replication Items: Existential Only") + 
  scale_fill_brewer(palette="Paired") +
  theme_classic() +
  ylim(0,1) + 
  theme(legend.position = "none")
```


```{r, echo=FALSE}
ReplicationOnly %>% 
  filter(type=="predicative") %>% 
  group_by(item,responseCase) %>% 
  count() %>% 
  pivot_wider(values_from = n, names_from = responseCase) %>% 
  summarize(nomRate = nom/(nom+gen)) %>% 
  ggplot(aes(x=reorder(item, -nomRate),y=nomRate, fill=item)) + 
  geom_bar(stat="identity") + 
  geom_text(aes(x=item,y=nomRate, vjust =-.5, label=trunc(nomRate*10^2))) +
  labs(x="Item", y="Proportion of Nominative Responses", title="Nominative Rates of Replication Items: Predicative Only") + 
  scale_fill_brewer(palette="Paired") +
  theme_classic() +
  ylim(0,1) + 
  theme(legend.position = "none")
```

### Demographic Factors

*Age*

```{r include=FALSE}
nomRates <- ReplicationOnly %>% 
  group_by(workerid,responseCase) %>% 
  count() %>% 
  pivot_wider(names_from = responseCase,values_from = n) %>% 
  summarize(NomRate = nom/22)
```

```{r include=FALSE}
ReplicationOnly <- left_join(ReplicationOnly,nomRates)
```

```{r echo=FALSE, message=FALSE}
ReplicationOnly %>% 
  filter(!is.na(age)) %>% 
#  filter(age < 60) %>% 
  ggplot(aes(x=age,y=NomRate)) + 
  geom_point() + 
  geom_smooth(method="lm") + 
  labs(y="Rate of Nominative Produced",title="Replication Results: Age")
```

*Education*

```{r echo=FALSE, message=FALSE}
ReplicationOnly %>% 
  filter(education != -1) %>% 
  ggplot(aes(x=education,y=NomRate)) + 
  geom_point() + 
  geom_smooth(method = "lm") + 
  labs(y="Rate of Nominative Produced",title="Replication Results: Age")
```

### Changes Over Time

```{r echo=FALSE, message=FALSE}
compItems %>% 
  rename("Item" = "item",
         "Voice" = "voice",
         "Structure" = "type",
         "Nominative Proportion (1976)" = "itemNomRateOriginal",
         "Nominative Proportion (2022)" = "itemNomRate",
         "Change (1976 -> 2022)" = "nomChange") %>% 
  formattable(align = c("l"), list(
  area(col = "Change (1976 -> 2022)") ~ color_tile("transparent", customGreen),
  area(col = "Nominative Proportion (2022)") ~ color_tile("transparent", "#e38f8f"),
  area(col = "Nominative Proportion (1976)") ~ color_tile("transparent", "#8fc4e3"))) %>% 
  as.datatable(escape = FALSE,
               options = list(scrollX = TRUE,
                              pageLength = 100),
               rownames = FALSE)
```



